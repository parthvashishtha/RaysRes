{"version":3,"sources":["../src/index.ts"],"names":[],"mappings":";AAAA,SAAS,SAAS,KAAc;AAC9B,SAAO,OAAO,QAAQ,YAAY,QAAQ,QAAQ,CAAC,MAAM,QAAQ,GAAG;AACtE;AAEA,SAAS,cAAc,KAAc;AACnC,SAAO,OAAO,QAAQ,YAAY,QAAQ,QAAQ,CAAC,OAAO,KAAK,GAAG,EAAE;AACtE;AAGA,SAAS,kBAAkB,KAAU;AACnC,QAAM,WAAW;AAEjB,MAAI,CAAC,SAAS,GAAG,KAAK,CAAC,MAAM,QAAQ,QAAQ,GAAG;AAC9C,WAAO;AAAA,EACT,WAAW,QAAQ,MAAM;AACvB,WAAO;AAAA,EACT;AAEA,MAAI,CAAC,MAAM,QAAQ,QAAQ,GAAG;AAC5B,WAAO,KAAK,QAAQ,EAAE,QAAQ,SAAO;AACnC,UAAI,QAAQ,SAAS,GAAG;AAExB,UAAI,OAAO,UAAU,YAAY,UAAU,MAAM;AAC/C,gBAAQ,kBAAkB,KAAK;AAE/B,YAAI,cAAc,KAAK,GAAG;AACxB,iBAAO,SAAS,GAAG;AAAA,QACrB,OAAO;AACL,mBAAS,GAAG,IAAI;AAAA,QAClB;AAAA,MACF,WAAW,UAAU,MAAM;AAAA,MAE3B;AAAA,IACF,CAAC;AAED,WAAO;AAAA,EACT;AAEA,WAAS,QAAQ,CAAC,GAAG,QAAQ;AAC3B,QAAI,QAAQ;AACZ,QAAI,OAAO,UAAU,YAAY,UAAU,MAAM;AAC/C,cAAQ,kBAAkB,KAAK;AAE/B,UAAI,cAAc,KAAK,GAAG;AACxB,eAAO,SAAS,GAAG;AAAA,MACrB,OAAO;AACL,iBAAS,GAAG,IAAI;AAAA,MAClB;AAAA,IACF,WAAW,UAAU,MAAM;AAEzB,aAAO,SAAS,GAAG;AAAA,IACrB;AAAA,EACF,CAAC;AAID,SAAO,SAAS,OAAO,QAAM,OAAO,MAAS;AAC/C;AAEe,SAAR,uBAA2C,KAAwB;AACxE,MAAI,QAAQ,QAAW;AACrB,WAAO;AAAA,EACT;AAIA,MAAI,mBAAmB,KAAK,MAAM,KAAK,UAAU,GAAG,CAAC;AAGrD,qBAAmB,kBAAkB,gBAAgB;AAGrD,MAAI,cAAc,gBAAgB;AAAG,WAAO;AAE5C,SAAO;AACT","sourcesContent":["function isObject(obj: unknown) {\n  return typeof obj === 'object' && obj !== null && !Array.isArray(obj);\n}\n\nfunction isEmptyObject(obj: unknown) {\n  return typeof obj === 'object' && obj !== null && !Object.keys(obj).length;\n}\n\n// Modified from here: https://stackoverflow.com/a/43781499\nfunction stripEmptyObjects(obj: any) {\n  const cleanObj = obj;\n\n  if (!isObject(obj) && !Array.isArray(cleanObj)) {\n    return cleanObj;\n  } else if (obj === null) {\n    return undefined;\n  }\n\n  if (!Array.isArray(cleanObj)) {\n    Object.keys(cleanObj).forEach(key => {\n      let value = cleanObj[key];\n\n      if (typeof value === 'object' && value !== null) {\n        value = stripEmptyObjects(value);\n\n        if (isEmptyObject(value)) {\n          delete cleanObj[key];\n        } else {\n          cleanObj[key] = value;\n        }\n      } else if (value === null) {\n        // Null properties in an object should remain!\n      }\n    });\n\n    return cleanObj;\n  }\n\n  cleanObj.forEach((o, idx) => {\n    let value = o;\n    if (typeof value === 'object' && value !== null) {\n      value = stripEmptyObjects(value);\n\n      if (isEmptyObject(value)) {\n        delete cleanObj[idx];\n      } else {\n        cleanObj[idx] = value;\n      }\n    } else if (value === null) {\n      // Null entries within an array should be removed.\n      delete cleanObj[idx];\n    }\n  });\n\n  // Since deleting a key from an array will retain an undefined value in that array, we need to\n  // filter them out.\n  return cleanObj.filter(el => el !== undefined);\n}\n\nexport default function removeUndefinedObjects<T>(obj?: T): T | undefined {\n  if (obj === undefined) {\n    return undefined;\n  }\n\n  // JSON.stringify removes undefined values. Though `[undefined]` will be converted with this to\n  // `[null]`, we'll clean that up next.\n  let withoutUndefined = JSON.parse(JSON.stringify(obj));\n\n  // Then we recursively remove all empty objects and nullish arrays.\n  withoutUndefined = stripEmptyObjects(withoutUndefined);\n\n  // If the only thing that's leftover is an empty object then return nothing.\n  if (isEmptyObject(withoutUndefined)) return undefined;\n\n  return withoutUndefined;\n}\n"]}