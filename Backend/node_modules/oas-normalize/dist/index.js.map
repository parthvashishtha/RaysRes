{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import type { Options } from './lib/types.js';\nimport type { OpenAPI, OpenAPIV2, OpenAPIV3 } from 'openapi-types';\n\nimport fs from 'node:fs';\n\nimport openapiParser from '@readme/openapi-parser';\nimport postmanToOpenAPI from '@readme/postman-to-openapi';\nimport converter from 'swagger2openapi';\n\nimport * as utils from './lib/utils.js';\n\nexport default class OASNormalize {\n  cache: {\n    bundle?: OpenAPI.Document | false;\n    deref?: OpenAPI.Document | false;\n    load?: Record<string, unknown> | false;\n  };\n\n  file: any;\n\n  opts: Options;\n\n  type: ReturnType<typeof utils.getType>;\n\n  constructor(file: any, opts?: Options) {\n    this.file = file;\n    this.opts = {\n      colorizeErrors: false,\n      enablePaths: false,\n      ...opts,\n    };\n\n    this.type = utils.getType(this.file);\n\n    this.cache = {\n      load: false,\n      bundle: false,\n      deref: false,\n    };\n  }\n\n  /**\n   * @private\n   */\n  async load(): Promise<Record<string, unknown>> {\n    if (this.cache.load) return Promise.resolve(this.cache.load);\n\n    const resolve = (obj: Parameters<typeof utils.stringToJSON>[0]) => {\n      const ret = utils.stringToJSON(obj);\n      this.cache.load = ret;\n      return Promise.resolve(ret);\n    };\n\n    switch (this.type) {\n      case 'json':\n      case 'string-json':\n      case 'string-yaml':\n        return resolve(this.file);\n\n      case 'buffer':\n        return resolve(this.file.toString());\n\n      case 'url':\n        const resp = await fetch(utils.normalizeURL(this.file)).then(res => res.text());\n        return resolve(resp);\n\n      case 'path':\n        // Load a local file\n        if (!this.opts.enablePaths) {\n          return Promise.reject(new Error('Use `opts.enablePaths` to enable accessing local files.'));\n        }\n\n        const contents = fs.readFileSync(this.file).toString();\n        if (!contents.trim()) {\n          return Promise.reject(new Error('No file contents found.'));\n        }\n        return resolve(contents);\n\n      default:\n        return Promise.reject(new Error('Could not load this file.'));\n    }\n  }\n\n  /**\n   * @private\n   */\n  static async convertPostmanToOpenAPI(schema: any) {\n    return postmanToOpenAPI(JSON.stringify(schema), undefined, { outputFormat: 'json', replaceVars: true }).then(\n      JSON.parse,\n    );\n  }\n\n  /**\n   * Bundle up the given API definition, resolving any external `$ref` pointers in the process.\n   *\n   */\n  async bundle() {\n    if (this.cache.bundle) return Promise.resolve(this.cache.bundle);\n\n    return this.load()\n      .then(schema => {\n        // Though Postman collections don't support `$ref` pointers for us to bundle we'll still\n        // upconvert it to an OpenAPI definition file so our returned dataset is always one of\n        // those for a Postman dataset.\n        if (utils.isPostman(schema)) {\n          return OASNormalize.convertPostmanToOpenAPI(schema);\n        }\n\n        return schema;\n      })\n      .then(schema => openapiParser.bundle(schema))\n      .then(bundle => {\n        this.cache.bundle = bundle;\n        return bundle;\n      });\n  }\n\n  /**\n   * Dereference the given API definition.\n   *\n   */\n  async deref() {\n    if (this.cache.deref) return Promise.resolve(this.cache.deref);\n\n    return this.load()\n      .then(schema => {\n        // Though Postman collections don't support `$ref` pointers for us to dereference we'll\n        // still upconvert it to an OpenAPI definition file so our returned dataset is always one\n        // of those for a Postman dataset.\n        if (utils.isPostman(schema)) {\n          return OASNormalize.convertPostmanToOpenAPI(schema);\n        }\n\n        return schema;\n      })\n      .then(schema => openapiParser.dereference(schema))\n      .then(dereferenced => {\n        this.cache.deref = dereferenced;\n        return dereferenced;\n      });\n  }\n\n  /**\n   * Validate, and potentially convert to OpenAPI, a given API definition.\n   *\n   */\n  async validate(\n    opts: {\n      /**\n       * Automatically convert the supplied API definition to the latest version of OpenAPI.\n       */\n      convertToLatest?: boolean;\n      parser?: openapiParser.Options;\n    } = { convertToLatest: false },\n  ): Promise<OpenAPI.Document> {\n    const convertToLatest = opts.convertToLatest;\n    const parserOptions = opts.parser || {};\n    if (!parserOptions.validate) {\n      parserOptions.validate = {};\n    }\n\n    parserOptions.validate.colorizeErrors = this.opts.colorizeErrors;\n\n    return this.load()\n      .then(async schema => {\n        if (!utils.isPostman(schema)) {\n          return schema;\n        }\n\n        return OASNormalize.convertPostmanToOpenAPI(schema);\n      })\n      .then(async schema => {\n        if (!utils.isSwagger(schema) && !utils.isOpenAPI(schema)) {\n          return Promise.reject(new Error('The supplied API definition is unsupported.'));\n        } else if (utils.isSwagger(schema)) {\n          const baseVersion = parseInt(schema.swagger, 10);\n          if (baseVersion === 1) {\n            return Promise.reject(new Error('Swagger v1.2 is unsupported.'));\n          }\n        }\n\n        /**\n         * `openapiParser.validate()` dereferences schemas at the same time as validation and does\n         * not give us an option to disable this. Since all we already have a dereferencing method\n         * on this library and our `validate()` method here just needs to tell us if the definition\n         * is valid or not we need to clone it before passing it over to `openapi-parser` so as to\n         * not run into pass-by-reference problems.\n         */\n        const clonedSchema = JSON.parse(JSON.stringify(schema));\n\n        return openapiParser\n          .validate(clonedSchema, parserOptions)\n          .then(() => {\n            if (!convertToLatest || utils.isOpenAPI(schema)) {\n              return schema;\n            }\n\n            return converter\n              .convertObj(schema, { anchors: true })\n              .then((options: { openapi: OpenAPI.Document }) => options.openapi);\n          })\n          .catch(err => Promise.reject(err));\n      });\n  }\n\n  /**\n   * Retrieve OpenAPI, Swagger, or Postman version information about the supplied API definition.\n   *\n   */\n  async version(): Promise<{ specification: 'openapi' | 'postman' | 'swagger'; version: string | 'unknown' }> {\n    return this.load().then(schema => {\n      switch (utils.getAPIDefinitionType(schema)) {\n        case 'openapi':\n          return {\n            specification: 'openapi',\n            version: (schema as unknown as OpenAPIV3.Document).openapi,\n          };\n\n        case 'postman':\n          let version = 'unknown';\n          if ((schema?.info as Record<string, string>)?.schema) {\n            // Though `info.schema` is required by the Postman spec there's no strictness to its\n            // contents so we'll do our best to extract a version out of this schema URL that they\n            // seem to usually match. If not we'll fallback to treating it as an `unknown` version.\n            const match = (schema?.info as Record<string, string>).schema.match(\n              /http(s?):\\/\\/schema.getpostman.com\\/json\\/collection\\/v([0-9.]+)\\//,\n            );\n\n            if (match) {\n              version = match[2];\n            }\n          }\n\n          return {\n            specification: 'postman',\n            version,\n          };\n\n        case 'swagger':\n          return {\n            specification: 'swagger',\n            version: (schema as unknown as OpenAPIV2.Document).swagger,\n          };\n\n        default:\n          throw new Error('Unknown file detected.');\n      }\n    });\n  }\n}\n"],"mappings":"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","names":[]}